from __future__ import annotations
from typing import List
import random

from Home import Home

class Chromosome:

    def __init__(self, 
                houses_list, 
                warehouse_locations_list):
        num_trucks = len(warehouse_locations_list)
        truck_route_size = len(houses_list)/num_trucks
        
        self.path_order = houses_list
        self.truck_warehouse_indices = warehouse_locations_list
        self.truck_routes = [[int(truck_route_size*x), int(truck_route_size*(x+1))] \
                                    for x in range(num_trucks)]
        # the last truck may have a shorter route, make sure it's last house to visit it's still in bounds
        self.truck_routes[-1][1] = len(houses_list)-1


    def mutate(self) -> Chromosome:
        """Mutation genetic operator used to generate a new child from
        an existing chromosome

        Raises:
            Exception: If any of the children made is invalid (missing homes)

        Returns:
            Chromosome: Chromosome generated by the mutation of the calling chromosome.
        """
        i = random.randint(0, len(self.path_order)-1)
        j = random.randint(0, len(self.path_order)-1)

        # swap 2 homes randomly along all truck routes
        mutated_path = self.path_order.copy()
        mutated_path[i], mutated_path[j] = mutated_path[j], mutated_path[i]
        new_chromosome = Chromosome(mutated_path, self.truck_warehouse_indices)
        
        if self.is_valid_path(new_chromosome.path_order):
            return new_chromosome
        else:
            raise Exception("Mutated path is not valid! + \n" + str(new_chromosome))


    def crossover(self, other_chromosome: Chromosome) -> List[Chromosome]:
        """Crossover used to generate 2 children from 2 existing parents

        Args:
            other_chromosome (Chromosome): The second parent to crossover with the
                                            calling chromosome.

        Raises:
            Exception: If any of the children made is invalid (missing homes)

        Returns:
            List[Chromosome]: 2 Children chromosomes generated by the crossover.
        """
        # let p be the split point of our chromosome
        # one side will have p elements, the other side has n-p
        crossover_index = random.randint(1, len(self.path_order)-1)
        
        # use the first p elements of the calling chromosome. Fill the rest using the missing elements
        # from 'other' (in order while avoiding duplicates) 
        new_path_1_left = self.path_order[:crossover_index]
        new_path_1_right = [x for x in other_chromosome.path_order if x not in new_path_1_left]
        new_path_1 = new_path_1_left + new_path_1_right

        # use the first p elements of the 'other' chromosome. Fill the rest using the missing elements
        # from calling chromosome (in order while avoiding duplicates) 
        new_path_2_right = self.path_order[crossover_index:]
        new_path_2_left = [x for x in other_chromosome.path_order if x not in new_path_2_right]
        new_path_2 = new_path_2_left + new_path_2_right

        # return the 2 new chromosomes (after verifying both are valid)
        new_child_chromosomes = [Chromosome(new_path_1, self.truck_warehouse_indices), \
                            Chromosome(new_path_2, self.truck_warehouse_indices)]

        for new_chrom in new_child_chromosomes:
            if not self.is_valid_path(new_chrom.path_order):
                raise Exception("Crossover path is not valid!: \n" + str(new_chrom))
        
        return new_child_chromosomes


    def is_valid_path(self, houses_list: List[Home]) -> bool:
        """Determines if this chromosome is valid. Valid meaning that every
        house is visited exactly once. Validity is determined using the 
        existing route as the reference.

        Args:
            houses_list (List[Home]): List of houses to validate the route of.

        Returns:
            bool: True if the route is valid. False otherwise.
        """
        for i in self.path_order:
            if i not in houses_list:
                return False
        return True


    def total_distance(self) -> float:
        """Calculates the distance for each truck from it's warehouse, to all of
        the houses on its route, back to its warehouse.

        Returns:
            float: Total distance for every truck route.
        """
        distance = 0
        for warehouse_idx, route in zip(self.truck_warehouse_indices, self.truck_routes):
            start, end = route
            # warehouse to first home
            distance += self.path_order[start].distance_to(warehouse_idx)
            # ith home to jth home (i>0 and j<# homes)
            for home_i, home_j in zip(self.path_order[start:end], self.path_order[start+1:end]):
                distance += home_i.distance_to(home_j.xy_index)
            # last home back to warehouse
            distance += self.path_order[end].distance_to(warehouse_idx)
        return distance
            


    def __str__(self):
        return "Chromosome with fitness: " + str(self.fitness())

    def __repr__(self):
        return "Chromosome with fitness: " + str(self.fitness())